/* Generated from orogen/lib/orogen/templates/tasks/Task.hpp */

#ifndef TRAJECTORY_GENERATION_TASK_TASK_HPP
#define TRAJECTORY_GENERATION_TASK_TASK_HPP

#include "trajectory_generation/TaskBase.hpp"

#include <ReflexxesAPI.h>
#include <RMLPositionFlags.h>
#include <RMLPositionInputParameters.h>
#include <RMLPositionOutputParameters.h>
#include "ConstrainedJointsTrajectory.hpp"
#include "trajectory_generationTypes.hpp"

namespace trajectory_generation {

class Task : public TaskBase
{
    friend class TaskBase;
protected:

    /** These are the motion constraints for the output trajectory. Will use max/min position, max vel, max acceleration and max jerk to shape the output trajectory.*/
    trajectory_generation::JointsMotionConstraints limits;
    /** Cycle time in seconds. IMPORTANT: This has to be the same value as the period of this component! */
    double cycle_time;
    /** RML Output position of previous cycle will be used as input for next cycle. If false, use the actual joint position (from joint_state port) as input for the next cycle. */
    bool override_input_position;
    /** RML Output speed of previous cycle will be used as input for next cycle. If false, use the actual joint speed (from joint_state port) as input for the next cycle. */
    bool override_input_speed;
    /** RML Output acceleration of previous cycle will be used as input for next cycle. If false, use the actual joint acceleration (from joint_state port) as input for the next cycle. */
    bool override_input_acceleration;
    /** Forcefully set the speed of the output command to this value (only for the specified joints) */
    base::samples::Joints override_output_speed;
    /** Forcefully set the acceleration of the output command to this value (only for the specified joints) */
    base::samples::Joints override_output_acceleration;
    /** Flag that specifies wheter to write debug data to port s or not */
    bool write_debug_data;
    /** Should an exception be thrown if input was infeasible, e.g. target speed too high? */
    bool throw_on_infeasible_input;

    size_t nDof;

    /** Input Parameters as used for Reflexxes for each sample. In debug mode they are written to corresponding output ports*/
    RMLInputParams debug_rml_input_params;
    /** Output Parameters from Reflexxes for each sample. In debug mode they are written to corresponding output ports*/
    RMLOutputParams debug_rml_output_params;

    //! For internal use
    ReflexxesAPI *RML;
    //! Configuration properties converted into Reflexxes type
    RMLPositionInputParameters *IP_static;
    //! To temporarily override Properties per sample
    RMLPositionInputParameters *IP_active;
    RMLPositionOutputParameters *OP;
    RMLPositionFlags Flags;
    std::stringstream feasibility_err;

    //! Current trajectory to follow. It has the same joint indexing as reflexxes types
    ConstrainedJointsTrajectory current_trajectory;
    //! Temporary storage for motion constraints of current via point
    JointsMotionConstraints current_motion_constraints;
    //! Temporary storage of new constrained trajectory target read from port
    ConstrainedJointsTrajectory input_constrained_trajectory_target;
    //!  Temporary storage of new trajectory target read from port
    base::JointsTrajectory input_trajectory_target;
    //!  Temporary storage of new position target read from port
    base::commands::Joints input_position_target;
    //!  Temporary storage of new constrained position target read from port
    ConstrainedJointsCmd input_constrained_position_target_;

    size_t current_step;
    bool has_target;
    bool do_write_command;
    double waypoint_accuracy;

    //! Joint state as read from port
    base::samples::Joints input_joint_state;
    //! Command to be written to output port
    base::samples::Joints output_command;
    //! Comamnd as generated by reflexxes, but converted to base types. Only used for debug purposes.
    base::samples::Joints rml_output_sample;
    base::Time prev_time;

    bool has_rml_been_called_once;

    /**
     * @brief Sets the currently active motion contraints according to motion_constraints
     *
     * If there is a joint undefine in motion_constraints that was previously configured,
     * the configured defualt constraints are used for that joint.
     *
     * If an invalid value (NaN) is set for a motion constraint in motion_constraints,
     * the configured default constraint is used instead.
     *
     * If there is a joint defined in motion_constraints it that was not previously
     * configured via properties, it is ignored.
     * TODO: Change this behavior. Method should
     * throw in this case.
     *
     */
    void set_active_motion_constraints(const JointsMotionConstraints& motion_constraints);

    /**
     * @brief Get default motion constraints for joint with name joint_name
     *
     * @throw base::JointLimits::InvalidName if joint name is unknown
     */
    void get_default_motion_constraints(const std::string& joint_name, JointMotionConstraints& constraints);
    void get_default_motion_constraints(size_t internal_index, JointMotionConstraints& constraints);
    void check_ctrl_mode(const base::JointState& command);

    /**
     * @brief Prepares internal data for processing a new target
     */
    void reset_for_new_command();

    /**
     * @brief Handles a new target of type base::commands::Joints
     *
     * Internally converts the joint sample into a ConstrainedJointsTrajectory and calls
     * handle_constrainted_trajectory_target
     *
     * @returns wether the input was feasible or had to modified to make it feasible
     */
    bool handle_position_target(const base::commands::Joints& sample);

    /**
     * @brief map_target_name_to_joint_idx Return internal id of joint name
     */
    size_t map_name_to_joint_idx(const std::string joint_name);

    /**
     * @brief Handles a new target of type trajectory_generation::ConstrainedJointsCmd
     *
     * Internally converts the joint sample into a ConstrainedJointsTrajectory and calls
     * handle_constrainted_trajectory_target
     *
     * @returns wether the input was feasible or had to modified to make it feasible
     */
    bool handle_constrained_position_target(const trajectory_generation::ConstrainedJointsCmd& sample);

    /**
     * @brief Handles a new target of type base:JointsTrajectory.
     *
     * Internally converts the joint sample into a ConstrainedJointsTrajectory and calls
     * handle_constrainted_trajectory_target
     *
     * @returns wether the input was feasible or had to modified to make it feasible
     */
    bool handle_trajectory_target(const base::JointsTrajectory& sample);

    /**
     * @brief Handles a new target of type ConstrainedJointsTrajectory.
     *
     * Prepared validation check of given.
     * @throw std::runtime_error if given trajectory is invalid.
     *
     * @returns wether the input was feasible or had to modified to make it feasible
     */
    bool handle_constrained_trajectory_target(const ConstrainedJointsTrajectory& sample);

    /**
     * @brief Internally set the current joint state
     *
     * Sets the internal representation of the joint state. Hereby override properties
     * are considered. Thus it is possible, that the actual set joint state might differ
     * than the one passed as argument.
     *
     * @param sample joint state to set internally
     */
    void set_current_joint_state(const base::samples::Joints& sample);

    /**
     * @brief Set the a subset of joints given in joint_names as active
     *
     * If a Joint defined from properties is _not_ within the vector, it will be set
     * as inactive for interpolation.
     *
     * If there is a joint define in joint_names which is not defined from properties,
     * it will be silently ignored.
     */
    void set_active_joints(const std::vector<std::string>& joint_names);

    /**
     * @brief Makes sure that all samples in the trajectory are valid within its
     *        contraints. If not, the trajectory is corrected.
     *
     * Caution: The trajectory given ans argument will be modified.
     *
     * @returns true if the trajectory was fesible. Returns false if not.
     */
    bool make_feasible(ConstrainedJointsTrajectory& sample);

    /**
     * @brief Handles the result of reflexxes control step
     *
     * Based on what the interpretation of result,
     *    - Nothing might happen -- If controlling and via point was not reached yet
     *    - The current via points get switched to the next -- If via point was reached
     *    - Runtime state change -- if error or limits violation was reported or end of trajectory was reached
     **/
    void handle_reflexxes_result_value(const int& result);

public:
    /** TaskContext constructor for Task
         * \param name Name of the task. This name needs to be unique to make it identifiable via nameservices.
         * \param initial_state The initial TaskState of the TaskContext. Default is Stopped state.
         */
    Task(std::string const& name = "trajectory_generation::Task");

    /** TaskContext constructor for Task
         * \param name Name of the task. This name needs to be unique to make it identifiable for nameservices.
         * \param engine The RTT Execution engine to be used for this task, which serialises the execution of all commands, programs, state machines and incoming events for a task.
         *
         */
    Task(std::string const& name, RTT::ExecutionEngine* engine);

    /** Default deconstructor of Task
         */
    ~Task();

    /** This hook is called by Orocos when the state machine transitions
         * from PreOperational to Stopped. If it returns false, then the
         * component will stay in PreOperational. Otherwise, it goes into
         * Stopped.
         *
         * It is meaningful only if the #needs_configuration has been specified
         * in the task context definition with (for example):
         \verbatim
         task_context "TaskName" do
           needs_configuration
           ...
         end
         \endverbatim
         */
    bool configureHook();

    /** This hook is called by Orocos when the state machine transitions
         * from Stopped to Running. If it returns false, then the component will
         * stay in Stopped. Otherwise, it goes into Running and updateHook()
         * will be called.
         */
    bool startHook();

    /** This hook is called by Orocos when the component is in the Running
         * state, at each activity step. Here, the activity gives the "ticks"
         * when the hook should be called.
         *
         * The error(), exception() and fatal() calls, when called in this hook,
         * allow to get into the associated RunTimeError, Exception and
         * FatalError states.
         *
         * In the first case, updateHook() is still called, and recover() allows
         * you to go back into the Running state.  In the second case, the
         * errorHook() will be called instead of updateHook(). In Exception, the
         * component is stopped and recover() needs to be called before starting
         * it again. Finally, FatalError cannot be recovered.
         */
    void updateHook();

    /** This hook is called by Orocos when the component is in the
         * RunTimeError state, at each activity step. See the discussion in
         * updateHook() about triggering options.
         *
         * Call recover() to go back in the Runtime state.
         */
    void errorHook();

    /** This hook is called by Orocos when the state machine transitions
         * from Running to Stopped after stop() has been called.
         */
    void stopHook();

    /** This hook is called by Orocos when the state machine transitions
         * from Stopped to PreOperational, requiring the call to configureHook()
         * before calling start() again.
         */
    void cleanupHook();
};
}

#endif

